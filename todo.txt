add error if use undeclared variable
refactor DETERMINE_X_RET


a= a++ doesn work
make a = a++ to have zero effect on stack


make user cast?
if 2.0+2.0 == 4


refactor equal in AST and compile.cpp

local variables are on stack
if we want to change them or read them,
we use indicies that we calcualte prior to usage of variables


rework token leaking to backend


fix stack getting bloated by unneccesaty set local command during init of local variable

clean up type stuff, where exactly do we keep our types in value or hash table for types?

have identifier in different node for code reuse

deal with token type to value type conversion on type check stage



conflict between type of init variable and call function 

pass wrong arguments

invoke a function that is not defined




we generate code when we want to get type of variable?

add support of single argument for


peephole optimiser
Constant Expression Folding

add errors of binary operations where operands of wrong type
add constant folding for cases where operators are different but constant folding is possible


 else
		 {	
			// we can also have cases with different but compatible operations 3 + a - 5 - they must be folded too
			// +- and -+ are converted to + and already taken care of
			// */
			// /*
			 bool isRightCompat= AreCompatible(expr->type, rightExpr->type);
			 bool isLeftCompat = AreCompatible(expr->type, leftExpr->type);


			 if (isLitL && isRightCompat)
			 {
				auto leftNode = FoldConstants(rightExpr->left.get());
				auto rightNode = FoldConstants(rightExpr->right.get());
				auto isLeftLiteralRightChild = isLiteral(leftNode->type);
				auto isRightLiteralRightChild = isLiteral(rightNode->type);
				assert(isLeftLiteralRightChild != isRightLiteralRightChild);
				if (isLeftLiteralRightChild)
				{
					CalculateConstant(ReverseOperation(expr->type), leftExpr, static_cast<Expression*>(leftNode), leftExpr);
				}
				else if (isRightLiteralRightChild)
				{
					CalculateConstant(ReverseOperation(expr->type), leftExpr, static_cast<Expression*>(rightNode), leftExpr);
				}
			 }
			 else if (isLitR && isLeftCompat)
			 {
				 auto leftNode = FoldConstants(leftExpr->left.get());
				 auto rightNode = FoldConstants(leftExpr->right.get());
				 auto isLeftLiteralLeftChild = isLiteral(leftNode->type);
				 auto isRightLiteralLeftChild = isLiteral(rightNode->type);
				 assert(isLeftLiteralLeftChild != isRightLiteralLeftChild);
				 if (isLeftLiteralLeftChild)
				 {
					 FoldConstantsWithVarAndOp(expr,leftNode, rightExpr,leftExpr);
					 expr->left = std::move(leftExpr->right);
					 left = nullptr;
					 //auto rightType = leftNode->type;
					 //if (expr->type == leftExpr->type)
					 //{
					//	CalculateConstant(expr->type, rightExpr, static_cast<Expression*>(leftNode), rightExpr);
					 //}
					 //else 
					 //{
					//	CalculateConstant(TokenType::SLASH, rightExpr,static_cast<Expression*>(leftNode),  rightExpr);
					 //}
					 //
					 //auto newType = (rightExpr->type == TokenType::FLOAT_LITERAL || rightType == TokenType::FLOAT_LITERAL)
					//	 ? TokenType::FLOAT_LITERAL : TokenType::INT_LITERAL;
					 //rightExpr->type = newType;
						 
				 }
				 else if (isRightLiteralLeftChild)
				 {
					 FoldConstantsWithVarAndOp(expr, rightNode, rightExpr, leftExpr);
					 expr->left = std::move(leftExpr->left);
					 left = nullptr;

				 }
			 }
		 }
