import "GLFW"
import "OpenGL-Legacy"

//--------------------------
// Game constants
//--------------------------
paddleHeight := 0.2;
paddleWidth  := 0.02;
paddleSpeed  := 0.02;

ballSize  := 0.03;
ballSpeedX := 0.01;
ballSpeedY := 0.01;

//--------------------------
// Paddles
//--------------------------
leftPaddleX  := -0.9;
rightPaddleX :=  0.9;
leftPaddleY  :=  0.0;
rightPaddleY :=  0.0;

//--------------------------
// Ball
//--------------------------
ballX := 0.0;
ballY := 0.0;

//--------------------------
// Drawing
//--------------------------
fun DrawRectangle(centerX: float, centerY: float, halfWidth: float, halfHeight: float) 
{
    // Calculate the rectangle’s corners
    //xMin := centerX - halfWidth;
    //xMax := centerX + halfWidth;
    //yMin := centerY - halfHeight;
    //yMax := centerY + halfHeight;

    glBegin(GL_QUADS);
        glVertex2f(centerX - halfWidth,  centerY - halfHeight);
        glVertex2f(centerX + halfWidth,  centerY - halfHeight);
        glVertex2f(centerX + halfWidth, centerY + halfHeight);
        glVertex2f(centerX - halfWidth, centerY + halfHeight);
    glEnd();
}


fun DrawGame() {
    // Clear screen
    glClear(GL_COLOR_BUFFER_BIT);

    // Draw left paddle
    glColor3f(1.0, 1.0, 1.0);
    DrawRectangle(leftPaddleX, leftPaddleY, paddleWidth, paddleHeight);

    // Draw right paddle
    DrawRectangle(rightPaddleX, rightPaddleY, paddleWidth, paddleHeight);

    // Draw ball
    glColor3f(1.0, 1.0, 0.0);
    DrawRectangle(ballX, ballY, ballSize, ballSize);
}

//--------------------------
// Game update
//--------------------------
fun UpdateGame() {
    // Move the ball
    ballX += ballSpeedX;
    ballY += ballSpeedY;

    // Bounce off top/bottom walls
    if (ballY + ballSize > 1.0 || ballY - ballSize < -1.0) {
        ballSpeedY = -ballSpeedY;
    }

    // Check collision with left paddle
    overlapXLeft := (ballX + ballSize >= (leftPaddleX - paddleWidth)) &&
                        (ballX - ballSize <= (leftPaddleX + paddleWidth));
    overlapYLeft := (ballY + ballSize >= (leftPaddleY - paddleHeight)) &&
                        (ballY - ballSize <= (leftPaddleY + paddleHeight));

    if (overlapXLeft && overlapYLeft) {
        // Reverse ball direction
        ballSpeedX = -ballSpeedX;
        // Optionally push ball outside the paddle so it doesn't get stuck
        ballX = leftPaddleX + paddleWidth + ballSize;
    }

    // Check collision with right paddle
    overlapXRight := (ballX + ballSize >= (rightPaddleX - paddleWidth)) &&
                         (ballX - ballSize <= (rightPaddleX + paddleWidth));
    overlapYRight := (ballY + ballSize >= (rightPaddleY - paddleHeight)) &&
                         (ballY - ballSize <= (rightPaddleY + paddleHeight));

    if (overlapXRight && overlapYRight) {
        // Reverse ball direction
        ballSpeedX = -ballSpeedX;
        // Optionally push ball outside the paddle so it doesn't get stuck
        ballX = rightPaddleX - paddleWidth - ballSize;
    }

    // Reset ball if completely out of bounds (missed the paddles)
    if (ballX < -1.0 || ballX > 1.0) {
        ballX = 0.0;
        ballY = 0.0;
        ballSpeedX = -ballSpeedX; // Keep it interesting by reversing X each reset
    }
}

//--------------------------
// Initialization
//--------------------------
if !glfwInit() {
    Print("Failed to initialize GLFW");
}

window := glfwCreateWindow(640, 480, "Ping Pong", nullptr, nullptr);
if !window {
    Print("Failed to create window");
} else {
    Print("Window created successfully");
}

glfwMakeContextCurrent(window);
glOrtho(-1.0, 1.0, -1.0, 1.0, -1.0, 1.0); // Coordinate system from -1..+1 on each axis

//--------------------------
// Main loop
//--------------------------
while !glfwWindowShouldClose(window) {
    // Player input
    if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) {
        leftPaddleY += paddleSpeed;
    }
    if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS) {
        leftPaddleY -= paddleSpeed;
    }
    if (glfwGetKey(window, GLFW_KEY_UP) == GLFW_PRESS) {
        rightPaddleY += paddleSpeed;
    }
    if (glfwGetKey(window, GLFW_KEY_DOWN) == GLFW_PRESS) {
        rightPaddleY -= paddleSpeed;
    }

    // (Optional) clamp paddles so they don't go off-screen:
    // leftPaddleY  = clamp( leftPaddleY,  -1.0 + paddleHeight, 1.0 - paddleHeight );
    // rightPaddleY = clamp( rightPaddleY, -1.0 + paddleHeight, 1.0 - paddleHeight );

    // Update game logic
    UpdateGame();

    // Render
    DrawGame();

    // Swap buffers and poll events
    glfwSwapBuffers(window);
    glfwPollEvents();
}

glfwDestroyWindow(window);
glfwTerminate();